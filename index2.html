<!DOCTYPE html>
<html>
<head>
<title>VueWordCloud</title>
<meta name="viewport" content="width=device-width,initial-scale=1.0,user-scalable=no"/>
<script src="https://cdnjs.cloudflare.com/ajax/libs/d3/4.10.0/d3.min.js"></script>
</head>
<body>

<script>
// Word cloud layout by Jason Davies, https://www.jasondavies.com/wordcloud/
// Algorithm due to Jonathan Feinberg, http://static.mrfeinberg.com/bv_ch03.pdf

let cw = 1 << 11 >> 5;
let ch = 1 << 11;

this.VueWordCloud = function() {
  let size = [256, 256],
	  text = cloudText,
	  font = cloudFont,
	  fontSize = cloudFontSize,
	  fontStyle = cloudFontNormal,
	  fontWeight = cloudFontNormal,
	  rotate = cloudRotate,
	  padding = cloudPadding,
	  spiral = archimedeanSpiral,
	  words = [],
	  timeInterval = Infinity,
	  timer = null,
	  random = Math.random,
	  cloud = {},
	  canvas = cloudCanvas;

	let containerSize = size;

  cloud.canvas = function(_) {
	return arguments.length ? (canvas = functor(_), cloud) : canvas;
  };

	cloud.start = function() {
		let canvas = document.createElement('canvas');
		let context = canvas.getContext('2d');
		canvas.width = (cw << 5);
		canvas.height = ch;
		context.fillStyle = context.strokeStyle = 'red';
		context.textAlign = 'center';
		let board = Array((size[0] >> 5) * size[1]).fill(0);
		let bounds = null;

		let wordElements = [];

		setTimeout(() => {
			words
				.map(function(d, i) {
					d.text = text.call(this, d, i);
					d.font = font.call(this, d, i);
					d.style = fontStyle.call(this, d, i);
					d.weight = fontWeight.call(this, d, i);
					d.rotate = rotate.call(this, d, i) / 360;
					d.size = ~~fontSize.call(this, d, i);
					d.padding = padding.call(this, d, i);

					d.position = containerSize.map(size => (size * (Math.random() + 1/2)) >> 1);

					return d;
				})
				.sort((word, otherWord) => otherWord.size - word.size)
				.forEach((word, i, words) => {
					word.x = word.position[0];
					word.y = word.position[1];
					cloudSprite(context, word, words, i);
					if (word.hasText && place(board, word, bounds)) {
						wordElements.push(word);
						if (bounds) {
							let b0 = bounds[0];
							let b1 = bounds[1];
							if (word.x + word.x0 < b0.x) {
								b0.x = word.x + word.x0;
							}
							if (word.y + word.y0 < b0.y) {
								b0.y = word.y + word.y0;
							}
							if (word.x + word.x1 > b1.x) {
								b1.x = word.x + word.x1;
							}
							if (word.y + word.y1 > b1.y) {
								b1.y = word.y + word.y1;
							}
						} else {
							bounds = [{x: word.x + word.x0, y: word.y + word.y0}, {x: word.x + word.x1, y: word.y + word.y1}];
						}

					}
				});
			drawNow(wordElements);
		}, 1);

		return cloud;
	};

function cloudSprite(context, d, data, di) {
		if (d.sprite) return;
		console.log('cloudSprite', d);
		context.clearRect(0, 0, context.canvas.width, context.canvas.height);

		let x = 0;
		let y = 0;
		let maxh = 0;
		let n = data.length;
		--di;
		while (++di < n) {
			d = data[di];
			context.save();

			let text = d.text;
			let fontSize = d.size;
			let fontFamily = d.font;
			let fontStyle = d.style;
			let fontWeight = d.weight;
			let padding = d.padding;
			let rotate = d.rotate;
			let font = [fontStyle, fontWeight, `${Math.round(fontSize)}px`, fontFamily].join(' ');

			context.font = font;
			let w = context.measureText(text).width;
			let h = fontSize << 1;
			if (rotate) {
				let sr = Math.sin(rotate * 2 * Math.PI);
				let cr = Math.cos(rotate * 2 * Math.PI);
				let wcr = w * cr;
				let wsr = w * sr;
				let hcr = h * cr;
				let hsr = h * sr;
				w = (Math.max(Math.abs(wcr + hsr), Math.abs(wcr - hsr)) + 0x1f) >> 5 << 5;
				h = ~~Math.max(Math.abs(wsr + hcr), Math.abs(wsr - hcr));
			} else {
				w = (w + 0x1f) >> 5 << 5;
			}
			if (h > maxh) {
				maxh = h;
			}
			if (x + w >= (cw << 5)) {
				x = 0;
				y += maxh;
				maxh = 0;
			}
			if (y + h >= ch) {
				break;
			}
			context.translate((x + (w / 2)), (y + (h  / 2)));
			if (rotate) {
				context.rotate(rotate * 2 * Math.PI);
			}
			context.fillText(text, 0, 0);
			if (padding) {
				context.lineWidth = 2 * padding;
				context.strokeText(text, 0, 0);
			}
			context.restore();
			d.width = w;
			d.height = h;
			d.xoff = x;
			d.yoff = y;
			d.x1 = w >> 1;
			d.y1 = h >> 1;
			d.x0 = -d.x1;
			d.y0 = -d.y1;
			d.hasText = true;
			x += w;
		}
		let pixels = context.getImageData(0, 0, (cw << 5), ch).data;
		let sprite = [];
		while (--di >= 0) {
			d = data[di];
			if (!d.hasText) continue;
			let w = d.width;
			let w32 = w >> 5;
			let h = d.y1 - d.y0;

			sprite.fill(0, 0, h * w32);

			x = d.xoff;
			if (x == null) return;
			y = d.yoff;
			let seen = 0;
			let seenRow = -1;
			for (let j = 0; j < h; j++) {
				for (let i = 0; i < w; i++) {
					let k = w32 * j + (i >> 5);
					let m = pixels[((y + j) * (cw << 5) + (x + i)) << 2] ? 1 << (31 - (i % 32)) : 0;
					sprite[k] |= m;
					seen |= m;
				}
				if (seen) {
					seenRow = j;
				} else {
					d.y0++;
					h--;
					j--;
					y++;
				}
			}
			d.y1 = d.y0 + seenRow;
			d.sprite = sprite.slice(0, (d.y1 - d.y0) * w32);
		}
	}

	function cloudCollide(tag, board, sw) {
		sw >>= 5;
		let sprite = tag.sprite;
		let w = tag.width >> 5;
		let lx = tag.x - (w << 4);
		let sx = lx & 0x7f;
		let msx = 32 - sx;
		let h = tag.y1 - tag.y0;
		let x = (tag.y + tag.y0) * sw + (lx >> 5);
		let last;
		for (let j = 0; j < h; j++) {
			last = 0;
			for (let i = 0; i <= w; i++) {
				if (((last << msx) | (i < w ? (last = sprite[j * w + i]) >>> sx : 0)) & board[x + i]) {
					return true;
				}
			}
			x += sw;
		}
		return false;
	}


function collideRects(a, b) {
  return a.x + a.x1 > b[0].x && a.x + a.x0 < b[1].x && a.y + a.y1 > b[0].y && a.y + a.y0 < b[1].y;
}

  function place(board, tag, bounds) {
	let perimeter = [{x: 0, y: 0}, {x: size[0], y: size[1]}],
		startX = tag.x,
		startY = tag.y,
		maxDelta = Math.sqrt(size[0] * size[0] + size[1] * size[1]),
		s = spiral(size),
		dt = random() < .5 ? 1 : -1,
		t = -dt,
		dxdy,
		dx,
		dy;

	while (dxdy = s(t += dt)) {
	  dx = ~~dxdy[0];
	  dy = ~~dxdy[1];

	  if (Math.min(Math.abs(dx), Math.abs(dy)) >= maxDelta) break;

	  tag.x = startX + dx;
	  tag.y = startY + dy;

	  if (tag.x + tag.x0 < 0 || tag.y + tag.y0 < 0 ||
		  tag.x + tag.x1 > size[0] || tag.y + tag.y1 > size[1]) continue;
	  // TODO only check for collisions within current bounds.
	  if (!bounds || !cloudCollide(tag, board, size[0])) {
		if (!bounds || collideRects(tag, bounds)) {
		  let {sprite} = tag,
			  w = tag.width >> 5,
			  sw = size[0] >> 5,
			  lx = tag.x - (w << 4),
			  sx = lx & 0x7f,
			  msx = 32 - sx,
			  h = tag.y1 - tag.y0,
			  x = (tag.y + tag.y0) * sw + (lx >> 5),
			  last;
		  for (let j = 0; j < h; j++) {
			last = 0;
			for (let i = 0; i <= w; i++) {
			  board[x + i] |= (last << msx) | (i < w ? (last = sprite[j * w + i]) >>> sx : 0);
			}
			x += sw;
		  }
		  return true;
		}
	  }
	}
	return false;
  }

  cloud.timeInterval = function(_) {
	return arguments.length ? (timeInterval = _ == null ? Infinity : _, cloud) : timeInterval;
  };

  cloud.words = function(_) {
	return arguments.length ? (words = _, cloud) : words;
  };

  cloud.size = function(_) {
	return arguments.length ? (size = [+_[0], +_[1]], cloud) : size;
  };

  cloud.font = function(_) {
	return arguments.length ? (font = functor(_), cloud) : font;
  };

  cloud.fontStyle = function(_) {
	return arguments.length ? (fontStyle = functor(_), cloud) : fontStyle;
  };

  cloud.fontWeight = function(_) {
	return arguments.length ? (fontWeight = functor(_), cloud) : fontWeight;
  };

  cloud.rotate = function(_) {
	return arguments.length ? (rotate = functor(_), cloud) : rotate;
  };

  cloud.text = function(_) {
	return arguments.length ? (text = functor(_), cloud) : text;
  };

  cloud.spiral = function(_) {
	return arguments.length ? (spiral = spirals[_] || _, cloud) : spiral;
  };

  cloud.fontSize = function(_) {
	return arguments.length ? (fontSize = functor(_), cloud) : fontSize;
  };

  cloud.padding = function(_) {
	return arguments.length ? (padding = functor(_), cloud) : padding;
  };

  cloud.random = function(_) {
	return arguments.length ? (random = _, cloud) : random;
  };

  cloud.on = function() {
	//let value = event.on.apply(event, arguments);
	//return value === event ? cloud : value;
  };

  return cloud;
};

function cloudText(d) {
  return d.text;
}

function cloudFont() {
  return 'serif';
}

function cloudFontNormal() {
  return 'normal';
}

function cloudFontSize(d) {
  return Math.sqrt(d.value);
}

function cloudRotate() {
  return (~~(Math.random() * 6) - 3) * 30;
}

function cloudPadding() {
  return 1;
}



function archimedeanSpiral(size) {
  let e = size[0] / size[1];
  return function(t) {
	return [e * (t *= .1) * Math.cos(t), t * Math.sin(t)];
  };
}

function rectangularSpiral(size) {
  let dy = 4,
	  dx = dy * size[0] / size[1],
	  x = 0,
	  y = 0;
  return function(t) {
	let sign = t < 0 ? -1 : 1;
	// See triangular numbers: T_n = n * (n + 1) / 2.
	switch ((Math.sqrt(1 + 4 * sign * t) - sign) & 3) {
	  case 0:  x += dx; break;
	  case 1:  y += dy; break;
	  case 2:  x -= dx; break;
	  default: y -= dy; break;
	}
	return [x, y];
  };
}



function cloudCanvas() {
  return document.createElement('canvas');
}

function functor(d) {
  return typeof d === 'function' ? d : function() { return d; };
}

let spirals = {
  archimedean: archimedeanSpiral,
  rectangular: rectangularSpiral
};


let words = Array.from({length: 100}, () => Math.random().toString(36))
	.map(function(d) {
	  return {text: d, size: 10 + Math.random() * 50};
	});

let layout;
setTimeout(() => {
	layout = VueWordCloud()
		.size([700, 700])
		.canvas(document.createElement('canvas'))
		.words(words)
		.timeInterval(100)
		//.padding(5)
		//.rotate(function() { return ~~(Math.random() * 2) * 90; })
		//.font('sans-serif')
		.text(function(d) { return d.text; })
		.fontSize(function(d) { return d.size; })
		//.on('end', function (words) { console.log(JSON.stringify(words)); })
		.start();
}, 1000);


function drawNow2(words) {
	let parent = document.createElement('div');
	parent.style.position = 'absolute';
	parent.style.left = `${layout.size()[0] + 100}px`;
	parent.style.top = `${0}px`;
	parent.style.width = `${layout.size()[0]}px`;
	parent.style.height = `${layout.size()[1]}px`;
	//parent.style.transform = `translate(${[`${layout.size()[0] / 2}px`, `${layout.size()[1] / 2}px`].join(',')})`;
	for (let word of words) {
		let div = document.createElement('div');
		div.style.fontSize = `${word.size}px`;
		div.style.fontFamily = 'serif';
		div.style.position = 'absolute';
		div.style.transform = [
			`translate(${[`${word.x}px`, `${word.y}px`].join(',')})`,
			`rotate(${word.rotate * 360}deg)`,
		].join(' ');

		let div2 = document.createElement('div');
		div2.style.position = 'absolute';
		div2.style.left = '50%';
		div2.style.top = '50%';
		div2.style.transform = 'translate(-50%, -50%)';
		div2.textContent = word.text;
		div.appendChild(div2);


		//div.style.transformOrigin = '50% 50%';
		parent.appendChild(div);
	}
	document.body.appendChild(parent);
}

function drawNow(words) {
  d3.select('body').append('svg')
	  .attr('width', layout.size()[0])
	  .attr('height', layout.size()[1])
	.append('g')
	  //.attr('transform', 'translate(' + layout.size()[0] / 2 + ',' + layout.size()[1] / 2 + ')')
	.selectAll('text')
	  .data(words)
	.enter().append('text')
	  .style('font-size', function(d) { return d.size + 'px'; })
	  .style('font-family', 'serif')
	  //.style('fill', function(d, i) { return fill(i); })
	  .attr('text-anchor', 'middle')
	  .attr('transform', function(d) {
		return 'translate(' + [d.x, d.y] + ')rotate(' + d.rotate * 360 + ')';
	  })
	  .text(function(d) { return d.text; });
	drawNow2(words);
}

</script>
</body>
</html>