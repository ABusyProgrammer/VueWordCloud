var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

(function (factory) {
	if (typeof module !== 'undefined' && typeof exports !== 'undefined' && this === exports) {
		module.exports = factory(require('vue'));
	} else {
		this.Vue.component('VueWordCloud', factory(this.Vue));
	}
}).call(this, function (Vue) {

	var CancelError = function (_Error) {
		_inherits(CancelError, _Error);

		function CancelError() {
			var _ref;

			_classCallCheck(this, CancelError);

			for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
				args[_key] = arguments[_key];
			}

			var _this = _possibleConstructorReturn(this, (_ref = CancelError.__proto__ || Object.getPrototypeOf(CancelError)).call.apply(_ref, [this].concat(args)));

			_this.name = 'CancelError';
			return _this;
		}

		return CancelError;
	}(Error);

	var Number_randomFloat = function Number_randomFloat(start, end) {
		return start + (end - start) * Math.random();
	};

	var Number_randomInt = function Number_randomInt(start, end) {
		var startInclusive = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
		var endInclusive = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

		if (start > end) {
			return Number_randomInt(end, start, endInclusive, startInclusive);
		}
		if (!startInclusive) start++;
		if (endInclusive) end++;
		return Math.floor(Number_randomFloat(start, end));
	};

	var Worker_fromString = function Worker_fromString(string) {
		var blob = new Blob([string]);
		var blobURL = URL.createObjectURL(blob);
		return new Worker(blobURL);
	};

	var Worker_getMessage = function Worker_getMessage(worker) {
		return new Promise(function (resolve, reject) {
			var cleanUp = void 0;
			var messageHandler = function messageHandler(event) {
				cleanUp(event);
				resolve(event.data);
			};
			var errorHandler = function errorHandler(event) {
				cleanUp(event);
				reject(event);
			};
			cleanUp = function cleanUp(event) {
				event.preventDefault();
				worker.removeEventListener('message', messageHandler);
				worker.removeEventListener('error', errorHandler);
			};
			worker.addEventListener('message', messageHandler);
			worker.addEventListener('error', errorHandler);
		});
	};

	var Promise_delay = function Promise_delay() {
		var ms = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;

		return new Promise(function (resolve) {
			return setTimeout(resolve, ms);
		});
	};

	var Function_isFunction = function Function_isFunction(value) {
		return typeof value === 'function';
	};

	var Function_noop = function Function_noop() {};

	var Function_stubArray = function Function_stubArray() {
		return [];
	};

	var Array_uniqueBy = function Array_uniqueBy(array, iteratee) {
		var uniqueValues = new Set();
		return array.filter(function (value) {
			value = iteratee(value);
			if (uniqueValues.has(value)) {
				return false;
			}
			uniqueValues.add(value);
			return true;
		});
	};

	var Array_shuffle = function Array_shuffle(array) {
		for (var i = array.length; i > 0;) {
			var j = Math.floor(Math.random() * i);
			i--;
			var _ref2 = [array[j], array[i]];
			array[i] = _ref2[0];
			array[j] = _ref2[1];
		}
		return array;
	};

	var Iterable_minOf = function Iterable_minOf(values, iteratee) {
		var returns = Infinity;
		var _iteratorNormalCompletion = true;
		var _didIteratorError = false;
		var _iteratorError = undefined;

		try {
			for (var _iterator = values[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
				var value = _step.value;

				returns = Math.min(iteratee(value), returns);
			}
		} catch (err) {
			_didIteratorError = true;
			_iteratorError = err;
		} finally {
			try {
				if (!_iteratorNormalCompletion && _iterator.return) {
					_iterator.return();
				}
			} finally {
				if (_didIteratorError) {
					throw _iteratorError;
				}
			}
		}

		return returns;
	};

	var Iterable_maxOf = function Iterable_maxOf(values, iteratee) {
		var returns = -Infinity;
		var _iteratorNormalCompletion2 = true;
		var _didIteratorError2 = false;
		var _iteratorError2 = undefined;

		try {
			for (var _iterator2 = values[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
				var value = _step2.value;

				returns = Math.max(iteratee(value), returns);
			}
		} catch (err) {
			_didIteratorError2 = true;
			_iteratorError2 = err;
		} finally {
			try {
				if (!_iteratorNormalCompletion2 && _iterator2.return) {
					_iterator2.return();
				}
			} finally {
				if (_didIteratorError2) {
					throw _iteratorError2;
				}
			}
		}

		return returns;
	};

	var Math_convertTurnToRad = function Math_convertTurnToRad(v) {
		return v * 2 * Math.PI;
	};

	var interpolateWeight = function interpolateWeight(weight, outputRange, maxWeight) {
		var minWeight = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;

		var input = weight;
		var inputMin = minWeight;
		var inputMax = maxWeight;
		var inputRange = [inputMin, inputMax];

		var _outputRange = _slicedToArray(outputRange, 2),
		    outputMin = _outputRange[0],
		    outputMax = _outputRange[1];

		if (outputMin === outputMax) {
			return outputMin;
		}

		if (inputMin === inputMax) {
			if (input <= inputMin) {
				return outputMin;
			}
			return outputMax;
		}

		var result = input;

		// Input Range
		result = (result - inputMin) / (inputMax - inputMin);

		// Output Range
		result = result * (outputMax - outputMin) + outputMin;
		return result;
	};

	var computed = {
		renderer: function renderer() {
			return this.domRenderer;
		},
		normalizedWords: function normalizedWords() {
			var _this2 = this;

			var words = this.words.map(function (word) {
				var text = void 0,
				    weight = void 0,
				    rotation = void 0,
				    fontFamily = void 0,
				    fontStyle = void 0,
				    fontVariant = void 0,
				    fontWeight = void 0,
				    color = void 0;
				if (word) {
					switch (typeof word === 'undefined' ? 'undefined' : _typeof(word)) {
						case 'string':
							{
								text = word;
								break;
							}
						case 'object':
							{
								if (Array.isArray(word)) {
									var _word = _slicedToArray(word, 2);

									text = _word[0];
									weight = _word[1];
								} else {
									text = word.text;
									weight = word.weight;
									rotation = word.rotation;
									fontFamily = word.fontFamily;
									fontStyle = word.fontStyle;
									fontVariant = word.fontVariant;
									fontWeight = word.fontWeight;
									color = word.color;
								}
								break;
							}
					}
				}
				if (text === undefined) {
					if (typeof _this2.text === 'function') {
						text = _this2.text(word);
					} else {
						text = _this2.text;
					}
				}
				if (weight === undefined) {
					if (typeof _this2.weight === 'function') {
						weight = _this2.weight(word);
					} else {
						weight = _this2.weight;
					}
				}
				if (rotation === undefined) {
					if (typeof _this2.rotation === 'function') {
						rotation = _this2.rotation(word);
					} else {
						rotation = _this2.rotation;
					}
				}
				if (fontFamily === undefined) {
					if (typeof _this2.fontFamily === 'function') {
						fontFamily = _this2.fontFamily(word);
					} else {
						fontFamily = _this2.fontFamily;
					}
				}
				if (fontStyle === undefined) {
					if (typeof _this2.fontStyle === 'function') {
						fontStyle = _this2.fontStyle(word);
					} else {
						fontStyle = _this2.fontStyle;
					}
				}
				if (fontVariant === undefined) {
					if (typeof _this2.fontVariant === 'function') {
						fontVariant = _this2.fontVariant(word);
					} else {
						fontVariant = _this2.fontVariant;
					}
				}
				if (fontWeight === undefined) {
					if (typeof _this2.fontWeight === 'function') {
						fontWeight = _this2.fontWeight(word);
					} else {
						fontWeight = _this2.fontWeight;
					}
				}
				if (color === undefined) {
					if (typeof _this2.color === 'function') {
						color = _this2.color(word);
					} else {
						color = _this2.color;
					}
				}
				return { text: text, weight: weight, rotation: rotation, fontFamily: fontFamily, fontStyle: fontStyle, fontVariant: fontVariant, fontWeight: fontWeight, color: color };
			});

			words = words.filter(function (_ref3) {
				var text = _ref3.text;
				return text;
			});
			words = words.filter(function (_ref4) {
				var weight = _ref4.weight;
				return weight > 0;
			});

			words = Array_uniqueBy(words, function (_ref5) {
				var text = _ref5.text;
				return text;
			});

			words.sort(function (word, otherWord) {
				return otherWord.weight - word.weight;
			});

			var minWeight = Iterable_minOf(words, function (_ref6) {
				var weight = _ref6.weight;
				return weight;
			});
			var maxWeight = Iterable_maxOf(words, function (_ref7) {
				var weight = _ref7.weight;
				return weight;
			});
			if (this.fontSizeRatio) {
				var _iteratorNormalCompletion3 = true;
				var _didIteratorError3 = false;
				var _iteratorError3 = undefined;

				try {
					for (var _iterator3 = words[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
						var word = _step3.value;

						word.weight = interpolateWeight(word.weight, [1, this.fontSizeRatio], maxWeight, minWeight);
					}
				} catch (err) {
					_didIteratorError3 = true;
					_iteratorError3 = err;
				} finally {
					try {
						if (!_iteratorNormalCompletion3 && _iterator3.return) {
							_iterator3.return();
						}
					} finally {
						if (_didIteratorError3) {
							throw _iteratorError3;
						}
					}
				}
			} else {
				var _iteratorNormalCompletion4 = true;
				var _didIteratorError4 = false;
				var _iteratorError4 = undefined;

				try {
					for (var _iterator4 = words[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
						var _word2 = _step4.value;

						_word2.weight /= minWeight;
					}
				} catch (err) {
					_didIteratorError4 = true;
					_iteratorError4 = err;
				} finally {
					try {
						if (!_iteratorNormalCompletion4 && _iterator4.return) {
							_iterator4.return();
						}
					} finally {
						if (_didIteratorError4) {
							throw _iteratorError4;
						}
					}
				}
			}

			return words;
		}
	};

	var getBoundedWords = function () {
		var getTextRect = async function getTextRect(text, fontFamily, fontSize, fontStyle, fontVariant, fontWeight, rotation) {
			rotation = Math_convertTurnToRad(rotation);
			var font = [fontStyle, fontVariant, fontWeight, fontSize + 'px', fontFamily].join(' ');
			try {
				await document.fonts.load(font, text);
			} catch (error) {
				// continue regardless of error
			}
			var ctx = document.createElement('canvas').getContext('2d');
			ctx.font = font;
			var textWidth = ctx.measureText(text).width;
			var textHeight = fontSize;
			var rectWidth = Math.ceil(textWidth * Math.abs(Math.cos(rotation)) + textHeight * Math.abs(Math.sin(rotation)));
			var rectHeight = Math.ceil(textWidth * Math.abs(Math.sin(rotation)) + textHeight * Math.abs(Math.cos(rotation)));
			var rectData = new Uint8Array(rectWidth * rectHeight);
			if (rectData.length > 0) {
				var _ctx = document.createElement('canvas').getContext('2d');
				_ctx.canvas.width = rectWidth;
				_ctx.canvas.height = rectHeight;
				_ctx.translate(rectWidth / 2, rectHeight / 2);
				_ctx.rotate(rotation);
				_ctx.font = font;
				_ctx.textAlign = 'center';
				_ctx.textBaseline = 'middle';
				_ctx.fillText(text, 0, 0);
				var imageData = _ctx.getImageData(0, 0, rectWidth, rectHeight).data;
				for (var i = 0, ii = rectData.length; i < ii; ++i) {
					rectData[i] = imageData[i * 4 + 3];
				}
			}
			return { textWidth: textWidth, textHeight: textHeight, rectWidth: rectWidth, rectHeight: rectHeight, rectData: rectData };
		};

		var boundWords = async function boundWords(context, containerWidth, containerHeight, words) {
			var boundedWords = [];
			var boundWordWorker = Worker_fromString("var _slicedToArray=function(){function a(a,b){var c=[],d=!0,e=!1,f=void 0;try{for(var g,h=a[Symbol.iterator]();!(d=(g=h.next()).done)&&(c.push(g.value),!(b&&c.length===b));d=!0);}catch(a){e=!0,f=a}finally{try{!d&&h['return']&&h['return']()}finally{if(e)throw f}}return c}return function(b,c){if(Array.isArray(b))return b;if(Symbol.iterator in Object(b))return a(b,c);throw new TypeError('Invalid attempt to destructure non-iterable instance')}}(),_typeof='function'==typeof Symbol&&'symbol'==typeof Symbol.iterator?function(a){return typeof a}:function(a){return a&&'function'==typeof Symbol&&a.constructor===Symbol&&a!==Symbol.prototype?'symbol':typeof a},_createClass=function(){function a(a,b){for(var c,d=0;d<b.length;d++)c=b[d],c.enumerable=c.enumerable||!1,c.configurable=!0,'value'in c&&(c.writable=!0),Object.defineProperty(a,c.key,c)}return function(b,c,d){return c&&a(b.prototype,c),d&&a(b,d),b}}();function _classCallCheck(a,b){if(!(a instanceof b))throw new TypeError('Cannot call a class as a function')}var RectCenterOutIterator=regeneratorRuntime.mark(function(a,b){var c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v;return regeneratorRuntime.wrap(function(w){for(var x=Math.ceil,y=Math.floor;;)switch(w.prev=w.next){case 0:if(!(0<a&&0<b)){w.next=76;break}if(c=void 0,d=void 0,a>b?(c=1,d=b/a):b>a?(d=1,c=a/b):c=d=1,e=y(a/2),f=y(b/2),g=a-e,h=b-f,!(e<g)){w.next=17;break}i=e;case 9:if(!(i<=g)){w.next=15;break}return w.next=12,[i,f];case 12:++i,w.next=9;break;case 15:w.next=25;break;case 17:if(!(f<h)){w.next=25;break}j=f;case 19:if(!(j<=h)){w.next=25;break}return w.next=22,[e,j];case 22:++j,w.next=19;break;case 25:k=e,l=f,m=g,n=h;case 29:if(!(g<a||h<b)){w.next=76;break}if(e-=c,f-=d,g+=c,h+=d,o=y(e),p=y(f),q=x(g),r=x(h),!(q>m)){w.next=46;break}s=p;case 40:if(!(s<r)){w.next=46;break}return w.next=43,[q,s];case 43:++s,w.next=40;break;case 46:if(!(r>n)){w.next=54;break}t=q;case 48:if(!(t>o)){w.next=54;break}return w.next=51,[t,r];case 51:--t,w.next=48;break;case 54:if(!(o<k)){w.next=62;break}u=r;case 56:if(!(u>p)){w.next=62;break}return w.next=59,[o,u];case 59:--u,w.next=56;break;case 62:if(!(p<l)){w.next=70;break}v=o;case 64:if(!(v<q)){w.next=70;break}return w.next=67,[v,p];case 67:++v,w.next=64;break;case 70:k=o,l=p,m=q,n=r,w.next=29;break;case 76:case'end':return w.stop();}},RectCenterOutIterator,this)}),AsyncQueue=function(){function a(){_classCallCheck(this,a),this._values=[]}return _createClass(a,[{key:'enqueue',value:function enqueue(a){this._values.push(a),this._promise&&this._resolvePromise()}},{key:'dequeue',value:async function dequeue(){for(var a=this;;){if(this._values.length)return this._values.shift();this._promise||(this._promise=new Promise(function(b){a._resolvePromise=b})),await this._promise,this._promise=void 0}}}]),a}();(async function(){var a=this,b=new AsyncQueue;this.addEventListener('message',function(a){var c=a.data;b.enqueue(c)});for(var c=await b.dequeue(),d=c.gridWidth,e=c.gridHeight,f=new Uint8Array(d*e),g=async function(){for(var c=await b.dequeue(),g=c.rectWidth,h=c.rectHeight,i=c.rectData,j=[],k=0;k<g;++k)for(var l=0;l<h;++l)i[g*l+k]&&j.push([k,l]);a.postMessage(function(){var a=!0,b=!1,c=void 0;try{for(var g,h,i=function(){var a=_slicedToArray(g.value,2),b=a[0],c=a[1];if(function(){var a=[],e=!0,g=!1,h=void 0;try{for(var i,j=occupiedRectPixels[Symbol.iterator]();!(e=(i=j.next()).done);e=!0){var k=_slicedToArray(i.value,2),l=k[0],m=k[1];if(l+=b,m+=c,f[d*m+l])return!1;a.push([l,m])}}catch(a){g=!0,h=a}finally{try{!e&&j.return&&j.return()}finally{if(g)throw h}}var n=!0,o=!1,p=void 0;try{for(var q,r=a[Symbol.iterator]();!(n=(q=r.next()).done);n=!0){var s=_slicedToArray(q.value,2),t=s[0],u=s[1];f[d*u+t]=1}}catch(a){o=!0,p=a}finally{try{!n&&r.return&&r.return()}finally{if(o)throw p}}return!0}())return{v:{rectLeft:b,rectTop:c}}},j=RectCenterOutIterator(d-rectWidth,e-rectHeight)[Symbol.iterator]();!(a=(g=j.next()).done);a=!0)if(h=i(),'object'===('undefined'==typeof h?'undefined':_typeof(h)))return h.v}catch(a){b=!0,c=a}finally{try{!a&&j.return&&j.return()}finally{if(b)throw c}}throw new Error}())};;)await g()}).call(self);");
			try {
				var gridResolution = Math.pow(2, 22);
				var gridWidth = Math.floor(Math.sqrt(containerWidth / containerHeight * gridResolution));
				var gridHeight = Math.floor(gridResolution / gridWidth);
				boundWordWorker.postMessage({ gridWidth: gridWidth, gridHeight: gridHeight });
				var _iteratorNormalCompletion5 = true;
				var _didIteratorError5 = false;
				var _iteratorError5 = undefined;

				try {
					for (var _iterator5 = words[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
						var word = _step5.value;

						context.throwIfCanceled();
						try {
							var text = word.text,
							    weight = word.weight,
							    rotation = word.rotation,
							    fontFamily = word.fontFamily,
							    fontStyle = word.fontStyle,
							    fontVariant = word.fontVariant,
							    fontWeight = word.fontWeight,
							    color = word.color;

							var fontSize = weight * 4;

							var _ref8 = await getTextRect(text, fontFamily, fontSize, fontStyle, fontVariant, fontWeight, rotation),
							    textWidth = _ref8.textWidth,
							    textHeight = _ref8.textHeight,
							    rectWidth = _ref8.rectWidth,
							    rectHeight = _ref8.rectHeight,
							    rectData = _ref8.rectData;

							boundWordWorker.postMessage({ rectWidth: rectWidth, rectHeight: rectHeight, rectData: rectData });

							var _ref9 = await Worker_getMessage(boundWordWorker),
							    rectLeft = _ref9.rectLeft,
							    rectTop = _ref9.rectTop;

							boundedWords.push({ text: text, rotation: rotation, fontFamily: fontFamily, fontSize: fontSize, fontStyle: fontStyle, fontVariant: fontVariant, fontWeight: fontWeight, rectLeft: rectLeft, rectTop: rectTop, rectWidth: rectWidth, rectHeight: rectHeight, textWidth: textWidth, textHeight: textHeight, color: color });
						} catch (error) {
							// continue regardless of error
						}
					}
				} catch (err) {
					_didIteratorError5 = true;
					_iteratorError5 = err;
				} finally {
					try {
						if (!_iteratorNormalCompletion5 && _iterator5.return) {
							_iterator5.return();
						}
					} finally {
						if (_didIteratorError5) {
							throw _iteratorError5;
						}
					}
				}
			} finally {
				boundWordWorker.terminate();
			}
			return boundedWords;
		};

		var scaleBoundedWords = function scaleBoundedWords(words, containerWidth, containerHeight, maxFontSize) {
			var minLeft = Iterable_minOf(words, function (_ref10) {
				var rectLeft = _ref10.rectLeft;
				return rectLeft;
			});
			var maxLeft = Iterable_maxOf(words, function (_ref11) {
				var rectLeft = _ref11.rectLeft,
				    rectWidth = _ref11.rectWidth;
				return rectLeft + rectWidth;
			});
			var containedWidth = maxLeft - minLeft;

			var minTop = Iterable_minOf(words, function (_ref12) {
				var rectTop = _ref12.rectTop;
				return rectTop;
			});
			var maxTop = Iterable_maxOf(words, function (_ref13) {
				var rectTop = _ref13.rectTop,
				    rectHeight = _ref13.rectHeight;
				return rectTop + rectHeight;
			});
			var containedHeight = maxTop - minTop;

			var scale = Math.min(containerWidth / containedWidth, containerHeight / containedHeight);

			var currentMaxFontSize = Iterable_maxOf(words, function (_ref14) {
				var fontSize = _ref14.fontSize;
				return fontSize;
			}) * scale;
			if (currentMaxFontSize > maxFontSize) {
				scale *= maxFontSize / currentMaxFontSize;
			}

			var _iteratorNormalCompletion6 = true;
			var _didIteratorError6 = false;
			var _iteratorError6 = undefined;

			try {
				for (var _iterator6 = words[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
					var word = _step6.value;

					word.rectLeft = (word.rectLeft - (minLeft + maxLeft) / 2) * scale + containerWidth / 2;
					word.rectTop = (word.rectTop - (minTop + maxTop) / 2) * scale + containerHeight / 2;
					word.rectWidth *= scale;
					word.rectHeight *= scale;
					word.textWidth *= scale;
					word.textHeight *= scale;
					word.fontSize *= scale;
				}
			} catch (err) {
				_didIteratorError6 = true;
				_iteratorError6 = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion6 && _iterator6.return) {
						_iterator6.return();
					}
				} finally {
					if (_didIteratorError6) {
						throw _iteratorError6;
					}
				}
			}
		};

		return async function (context) {
			var containerWidth = this.containerWidth;
			var containerHeight = this.containerHeight;
			if (containerWidth <= 0 || containerHeight <= 0) {
				return [];
			}
			var maxFontSize = this.maxFontSize;
			var words = this.normalizedWords;
			await context.delayIfNotCanceled();
			var boundedWords = await boundWords(context, containerWidth, containerHeight, words);
			await context.delayIfNotCanceled();
			scaleBoundedWords(boundedWords, containerWidth, containerHeight, maxFontSize);
			await context.delayIfNotCanceled();
			return boundedWords;
		};
	}();

	var asyncComputed = {
		boundedWords: {
			get: getBoundedWords,
			default: Function_stubArray
		}
	};

	var watch = {};

	var invokePeriodically = {
		updateContainerSize: {
			method: function method() {
				if (this.mounted && this.$el) {
					var _$el$getBoundingClien = this.$el.getBoundingClientRect(),
					    width = _$el$getBoundingClien.width,
					    height = _$el$getBoundingClien.height;

					this.containerWidth = width;
					this.containerHeight = height;
				}
			},


			//initialDelay

			interval: function interval() {
				return this.containerSizeUpdateInterval;
			}
		}
	};

	var methods = {
		domRenderer: function domRenderer(createElement) {
			var words = [].concat(_toConsumableArray(this.boundedWords));
			//Array_shuffle(words);
			var wordsCount = words.length;
			var transitionDuration = this.animationDuration / 2;
			var transitionDelay = transitionDuration / wordsCount;
			var transitionEasing = this.animationEasing;
			return createElement('div', {
				style: {
					position: 'relative',
					width: '100%',
					height: '100%',
					overflow: 'hidden'
				}
			}, words.map(function (_ref15, index) {
				var text = _ref15.text,
				    color = _ref15.color,
				    fontFamily = _ref15.fontFamily,
				    fontSize = _ref15.fontSize,
				    fontStyle = _ref15.fontStyle,
				    fontVariant = _ref15.fontVariant,
				    fontWeight = _ref15.fontWeight,
				    rotation = _ref15.rotation,
				    rectLeft = _ref15.rectLeft,
				    rectTop = _ref15.rectTop,
				    rectWidth = _ref15.rectWidth,
				    rectHeight = _ref15.rectHeight,
				    textWidth = _ref15.textWidth,
				    textHeight = _ref15.textHeight;
				return createElement('div', {
					key: text,
					style: {
						position: 'absolute',
						left: rectLeft + rectWidth / 2 - textWidth / 2 + 'px',
						top: rectTop + rectHeight / 2 + 'px',
						color: color,
						font: [fontStyle, fontVariant, fontWeight, fontSize + 'px/0', fontFamily].join(' '),
						transform: 'rotate(' + rotation + 'turn)',
						whiteSpace: 'nowrap',
						transition: ['all', Math.round(transitionDuration) + 'ms', transitionEasing, Math.round(transitionDelay * index) + 'ms'].join(' ')
					}
				}, text);
			}));
		},
		canvasRenderer: function canvasRenderer(createElement) {
			var canvas = document.createElement('canvas');
			var ctx = canvas.getContext('2d');
			this.boundedWords.forEach(function (_ref16) {
				var text = _ref16.text,
				    color = _ref16.color,
				    fontFamily = _ref16.fontFamily,
				    fontSize = _ref16.fontSize,
				    fontStyle = _ref16.fontStyle,
				    fontVariant = _ref16.fontVariant,
				    fontWeight = _ref16.fontWeight,
				    rotation = _ref16.rotation,
				    rectLeft = _ref16.rectLeft,
				    rectTop = _ref16.rectTop,
				    rectWidth = _ref16.rectWidth,
				    rectHeight = _ref16.rectHeight,
				    textWidth = _ref16.textWidth,
				    textHeight = _ref16.textHeight;

				ctx.save();
				ctx.font = [fontStyle, fontVariant, fontWeight, fontSize + 'px', fontFamily].join(' ');
				ctx.fillStyle = color;
				ctx.textAlign = 'center';
				ctx.textBaseline = 'middle';
				ctx.fillText(text, 0, 0);
				ctx.translate(rectLeft + rectWidth / 2, rectTop + rectHeight / 2);
				ctx.rotate(Math_convertTurnToRad(rotation));
				ctx.restore();
			});
			return canvas;
		},
		svgRenderer: function svgRenderer(createElement) {
			// todo?
		}
	};

	(function () {
		var CancelableContext = function () {
			function CancelableContext() {
				_classCallCheck(this, CancelableContext);

				this.canceled = false;
			}

			_createClass(CancelableContext, [{
				key: 'cancel',
				value: function cancel() {
					this.canceled = true;
				}
			}, {
				key: 'throwIfCanceled',
				value: function throwIfCanceled() {
					if (this.canceled) {
						throw new CancelError();
					}
				}
			}, {
				key: 'delayIfNotCanceled',
				value: async function delayIfNotCanceled(ms) {
					this.throwIfCanceled();
					await Promise_delay(ms);
					this.throwIfCanceled();
				}
			}]);

			return CancelableContext;
		}();

		var prefixA = 'duqugwtjleyi$';
		var prefixB = 'xvvzxtpxrfjr$';

		Object.entries(asyncComputed).forEach(function (_ref17) {
			var _Object$assign;

			var _ref18 = _slicedToArray(_ref17, 2),
			    key = _ref18[0],
			    def = _ref18[1];

			var keyA = prefixA + key;
			var keyB = prefixB + key;

			Object.assign(computed, (_Object$assign = {}, _defineProperty(_Object$assign, keyA, function () {
				return this[keyB]();
			}), _defineProperty(_Object$assign, keyB, function () {
				var outerContext = void 0;
				return async function () {
					var _def$get;

					if (outerContext) {
						outerContext.cancel();
					}
					var innerContext = outerContext = new CancelableContext();

					for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
						args[_key2] = arguments[_key2];
					}

					var returns = await (_def$get = def.get).call.apply(_def$get, [this, innerContext].concat(args));
					innerContext.throwIfCanceled();
					return returns;
				};
			}), _Object$assign));
			Object.assign(watch, _defineProperty({}, keyA, {
				handler: async function handler(promise) {
					try {
						this[key] = await promise;
					} catch (error) {
						// continue regardless of error
					}
				},

				immediate: true
			}));
		});
	})();

	(function () {
		var prefixA = 'wkoojrkxgnng$';
		var prefixB = 'ozyvltnleyhp$';

		Object.entries(invokePeriodically).forEach(function (_ref19) {
			var _Object$assign4;

			var _ref20 = _slicedToArray(_ref19, 2),
			    key = _ref20[0],
			    def = _ref20[1];

			var keyA = prefixA + key;
			var keyB = prefixB + key;

			Object.assign(methods, _defineProperty({}, key, def.method));
			Object.assign(computed, (_Object$assign4 = {}, _defineProperty(_Object$assign4, keyA, function () {
				return this[keyB]();
			}), _defineProperty(_Object$assign4, keyB, function () {
				var id = void 0;
				return function () {
					var _this3 = this;

					clearTimeout(id);
					var tvrsadrhbmtf = function tvrsadrhbmtf() {
						if (!_this3.destroyed) {
							id = setTimeout(tvrsadrhbmtf, Function_isFunction(def.interval) ? def.interval.call(_this3) : def.interval);
							_this3[key]();
						}
					};
					tvrsadrhbmtf();
				};
			}), _Object$assign4));
			Object.assign(watch, _defineProperty({}, keyA, {
				handler: function handler() {},
				immediate: true }));
		});
	})();

	return {
		render: function render(createElement) {
			return this.renderer(createElement);
		},


		props: {
			words: {
				type: Array,
				default: function _default() {
					return [];
				}
			},

			text: {
				type: [String, Function],
				default: ''
			},

			weight: {
				type: [Number, Function],
				default: 1
			},

			rotation: {
				type: [String, Function],
				default: function _default() {
					var values = [0, 3 / 4];
					return function () {
						return values[Math.floor(Math.random() * values.length)];
					};
				}
			},

			fontFamily: {
				type: [String, Function],
				default: 'serif'
			},

			fontStyle: {
				type: [String, Function],
				default: 'normal'
			},

			fontVariant: {
				type: [String, Function],
				default: 'normal'
			},

			fontWeight: {
				type: [String, Function],
				default: 'normal'
			},

			color: {
				type: [String, Function],
				default: 'Black'
			},

			fontSizeRatio: {
				type: Number,
				default: 1
			},

			maxFontSize: {
				type: Number,
				default: Infinity
			},

			animationDuration: {
				type: Number,
				default: 5000
			},

			animationEasing: {
				type: String,
				default: 'ease'
			},

			containerSizeUpdateInterval: {
				type: Number,
				default: 1000
			}
		},

		data: function data() {
			var _this4 = this;

			var data = {
				mounted: false,
				destroyed: false,
				animatedBoundedWords: [],
				containerWidth: 0,
				containerHeight: 0
			};
			Object.entries(asyncComputed).forEach(function (_ref21) {
				var _ref22 = _slicedToArray(_ref21, 2),
				    key = _ref22[0],
				    def = _ref22[1];

				data[key] = Function_isFunction(def.default) ? def.default.call(_this4) : def.default;
			});
			return data;
		},
		mounted: function mounted() {
			this.mounted = true;
		},
		beforeDestroy: function beforeDestroy() {
			this.destroyed = true;
		},


		computed: computed,
		watch: watch,
		methods: methods
	};
});